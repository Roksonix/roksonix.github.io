<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Doto:wght@400;700;900&family=Pixelify+Sans:wght@400;700&display=swap" rel="stylesheet">
        <title>Volodymyr Vashchuk — CV</title>
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <main id="viewport">
          <section id="intro" class="section intro gate-active" data-title="Intro">
            <div class="intro-content animate">
              <div class="cube-wrap" aria-hidden="true">
                <div class="cube" id="intro-cube">
                  <div class="face front"><span>V</span></div>
                  <div class="face back"><span>L</span></div>
                  <div class="face right"><span>O</span></div>
                  <div class="face left"><span>O</span></div>
                  <div class="face top"></div>
                  <div class="face bottom"></div>
                </div>
              </div>
              <p class="tagline">Let's develop impactful things together</p>
            </div>
          </section>
          <section id="summary" class="section summary" data-title="Summary">
            <div class="content animate">
              <div class="summary-grid">
                <div class="summary-main">
                  <h2 class="title">About me</h2>
                  <p class="lead">
                    Senior Frontend Engineer with multiple years of experience building and maintaining
                    web applications, delivering architecture proposals, and creating proof‑of‑concepts.
                  </p>
                  <p class="lead">
                    Proficient in JavaScript/Typescript, lots of experience with React ecosystem (Redux, RTK, React Query). Experienced with Next.JS.
                    I'm always looking for new ways to improve the way I work and learn new things. AI empowered developer.
                  </p>
                </div>
                <aside class="summary-aside" aria-label="Highlights">
                  <div class="stat">
                    <div class="stat-head"><span class="label">Experience</span><span class="value">8+ yrs</span></div>
                    <div class="bar" style="--v:.95"></div>
                  </div>
                  <div class="stat">
                    <div class="stat-head"><span class="label">Architecture</span><span class="value">high</span></div>
                    <div class="bar" style="--v:.85"></div>
                  </div>
                  <div class="stat">
                    <div class="stat-head"><span class="label">Mentoring</span><span class="value">strong</span></div>
                    <div class="bar" style="--v:.8"></div>
                  </div>
                </aside>
              </div>
            </div>
          </section>

          <section id="skills" class="section skills" data-title="Skills">
            <div class="content animate">
              <h2 class="title">Core skills</h2>
              <div class="pill-grid">
                <span class="pill">JavaScript</span>
                <span class="pill">TypeScript</span>
                <span class="pill">React</span>
                <span class="pill">Redux / RTK</span>
                <span class="pill">React Query</span>
                <span class="pill">HTML5</span>
                <span class="pill">CSS</span>
                <span class="pill">AEM</span>
                <span class="pill">MACH</span>
                <span class="pill">Webpack</span>
                <span class="pill">Gulp</span>
                <span class="pill">GitHub Actions</span>
                <span class="pill">Jenkins</span>
                <span class="pill">GitLab CI</span>
                <span class="pill">AWS (basic)</span>
                <span class="pill">Firebase (basic)</span>
                <span class="pill">Jest</span>
                <span class="pill">React Testing Library</span>
              </div>
            </div>
          </section>

          <section class="section step" id="similarweb" data-title="Similarweb" data-period="Nov 2024 — Present" data-location="Prague, Czechia">
            <div class="content animate">
              <h2 class="eyebrow">Similarweb</h2>
              <h3 class="title">Senior Software Engineer</h3>
              <p class="meta">Nov 2024 — Present · Prague, Czechia</p>
              <p class="desc">Details coming soon.</p>
            </div>
          </section>

          <section class="section step" id="sentinelone" data-title="SentinelOne" data-period="Sep 2024 — Oct 2024" data-location="Prague, Czechia">
            <div class="content animate">
              <h2 class="eyebrow">SentinelOne</h2>
              <h3 class="title">Staff Software Engineer</h3>
              <p class="meta">Sep 2024 — Oct 2024 · Prague, Czechia</p>
              <p class="desc">Details coming soon.</p>
            </div>
          </section>

          <section class="section outro" id="contact" data-title="Contact">
            <div class="content animate">
              <h2 class="title">Let’s connect</h2>
              <p class="lead">Open to challenging Frontend roles and architecture‑driven projects.</p>
              <div class="cta-row">
                <a class="btn primary" href="mailto:roksonix@gmail.com">Email me</a>
                <a class="btn ghost" href="Profile.pdf" download>Download PDF</a>
              </div>
            </div>
          </section>
        </main>


        <script defer>
          const supportsScrollDriven = CSS && CSS.supports?.("animation-timeline: view()");
          document.documentElement.classList.toggle("no-sd", !supportsScrollDriven);

          if (!supportsScrollDriven && "IntersectionObserver" in window) {
            const observer = new IntersectionObserver(
              (entries) => {
                for (const entry of entries) {
                  if (entry.isIntersecting) entry.target.classList.add("is-visible");
                }
              },
              { root: document.querySelector('#viewport'), threshold: 0.25 }
            );
            document.querySelectorAll('.section .content').forEach((el) => observer.observe(el));
          }



          if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
            document.documentElement.classList.add('reduced-motion');
          }
          (function introGate(){
            const viewport = document.getElementById('viewport');
            const section = document.getElementById('intro');
            const cube = document.getElementById('intro-cube');
            if (!viewport || !section || !cube) return;

            // Gate only while intro is in view the first time
            let gated = true;
            let rotationY = 30; // start angle must match CSS start
            let lastTs = 0;
            let pinnedScrollTop = viewport.scrollTop; // pin at current position

            const applyRotation = () => {
              cube.style.transform = `rotateX(-18deg) rotateY(${rotationY}deg)`;
            };
            applyRotation();

            const endGate = () => {
              if (!gated) return;
              gated = false;
              section.classList.remove('gate-active');
              cube.classList.add('spin');
            };

            const isIntroTopNearTop = () => {
              const rect = section.getBoundingClientRect();
              const vp = viewport.getBoundingClientRect();
              // Consider intro at top when its top is within 8px of viewport top
              return Math.abs(rect.top - vp.top) < 8;
            };

            const wheelHandler = (e) => {
              if (!gated) return;
              if (!isIntroTopNearTop()) { endGate(); return; }
              if (e.deltaY <= 0) return; // allow upward scroll naturally
              e.preventDefault();
              // Progress rotation by wheel delta
              rotationY = Math.max(-90, rotationY - e.deltaY * 0.35);
              applyRotation();
              if (rotationY <= -90) { endGate(); }
            };

            let touchStartY = null;
            const touchStart = (e) => { if (!gated) return; touchStartY = e.touches[0].clientY; };
            const touchMove = (e) => {
              if (!gated || touchStartY == null) return;
              if (!isIntroTopNearTop()) { endGate(); return; }
              const dy = touchStartY - e.touches[0].clientY; // swipe up positive
              if (dy <= 0) return;
              e.preventDefault();
              rotationY = Math.max(-90, rotationY - dy * 0.4);
              applyRotation();
              if (rotationY <= -90) { endGate(); }
            };
            const touchEnd = () => { touchStartY = null; };

            const keyHandler = (e) => {
              if (!gated) return;
              if (!isIntroTopNearTop()) { endGate(); return; }
              const keys = ['PageDown','ArrowDown','Space'];
              if (!keys.includes(e.key)) return;
              e.preventDefault();
              rotationY = Math.max(-90, rotationY - 10);
              applyRotation();
              if (rotationY <= -90) { endGate(); }
            };

            const onScroll = () => {
              if (!gated) return;
              const rect = section.getBoundingClientRect();
              const vp = viewport.getBoundingClientRect();
              // Keep gating only when intro is at the top edge
              if (Math.abs(rect.top - vp.top) > 8) { endGate(); return; }
              section.classList.add('gate-active');
              // Pin scroll to prevent container movement while rotating
              viewport.scrollTop = pinnedScrollTop;
            };

            viewport.addEventListener('wheel', wheelHandler, { passive: false });
            viewport.addEventListener('scroll', onScroll);
            viewport.addEventListener('touchstart', touchStart, { passive: true });
            // Prevent default space/arrow scroll while gated
            window.addEventListener('keydown', (e) => {
              if (!gated) return;
              const block = ['Space','ArrowDown','PageDown'];
              if (block.includes(e.key)) e.preventDefault();
            }, { capture: true });
            viewport.addEventListener('touchmove', touchMove, { passive: false });
            viewport.addEventListener('touchend', touchEnd, { passive: true });
            window.addEventListener('keydown', keyHandler);

            // When gate completes, unhook pinning and allow normal scroll
            const observer = new MutationObserver(() => {
              if (!section.classList.contains('gate-active')) {
                observer.disconnect();
                // no-op: listeners can remain; gating checks will ignore
              }
            });
            observer.observe(section, { attributes: true, attributeFilter: ['class'] });
          })();

          (function cubeFallback(){
            const cube = document.getElementById('intro-cube');
            const section = document.getElementById('intro');
            const viewport = document.getElementById('viewport');
            const reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            const supports = CSS && CSS.supports?.('animation-timeline: view()');
            if (!cube || !section || !viewport || supports || reduced) return;
            if (section.classList.contains('gate-active')) return; // disabled during gate
            if (document.getElementById('intro-cube')?.classList.contains('spin')) return; // already spinning
            const degStart = 30;
            const degEnd = -90;
            const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
            const lerp = (a, b, t) => a + (b - a) * t;
            const update = () => {
              const vpRect = viewport.getBoundingClientRect();
              const secRect = section.getBoundingClientRect();
              const range = vpRect.height + secRect.height;
              const progress = clamp((vpRect.bottom - secRect.top) / range, 0, 1);
              const y = lerp(degStart, degEnd, progress);
              cube.style.transform = `rotateX(-18deg) rotateY(${y}deg)`;
            };
            update();
            viewport.addEventListener('scroll', update, { passive: true });
            window.addEventListener('resize', update);
          })();
        </script>
    </body>
</html>
