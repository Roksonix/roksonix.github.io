<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Volodymyr Vashchuk — CV</title>
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <main id="viewport">
          <section id="intro" class="section intro gate-active" data-title="Intro">
            <div class="intro-content animate">
              <div class="cube-wrap" aria-hidden="true">
                <div class="cube" id="intro-cube">
                  <div class="face front"><span>V</span></div>
                  <div class="face back"><span>L</span></div>
                  <div class="face right"><span>O</span></div>
                  <div class="face left"><span>O</span></div>
                  <div class="face top"></div>
                  <div class="face bottom"></div>
                </div>
              </div>
              <p class="tagline">Let's develop impactful things together</p>
            </div>
          </section>
          <section id="summary" class="section hero" data-title="Summary">
            <div class="content animate">
              <h2 class="title">About me</h2>
              <p class="lead">
                Senior Frontend Engineer with 8+ years of experience building and maintaining
                web applications, delivering architecture proposals, and creating proof‑of‑concepts.
              </p>
              <ul class="bullets">
                <li>JavaScript / TypeScript, React ecosystem (Redux, RTK, React Query)</li>
                <li>HTML5 / CSS with accessibility and performance focus</li>
                <li>CI/CD: Gulp, Webpack, GitHub Actions, Jenkins, GitLab CI</li>
                <li>Basics with AWS and Firebase</li>
                <li>Scrum and Kanban; estimations, planning, code reviews</li>
                <li>TDD mindset; Jest + React Testing Library</li>
                <li>Mentoring, onboarding, and technical interviews</li>
              </ul>
            </div>
          </section>

          <section id="skills" class="section skills" data-title="Skills">
            <div class="content animate">
              <h2 class="title">Core skills</h2>
              <div class="pill-grid">
                <span class="pill">JavaScript</span>
                <span class="pill">TypeScript</span>
                <span class="pill">React</span>
                <span class="pill">Redux / RTK</span>
                <span class="pill">React Query</span>
                <span class="pill">HTML5</span>
                <span class="pill">CSS</span>
                <span class="pill">AEM</span>
                <span class="pill">MACH</span>
                <span class="pill">Webpack</span>
                <span class="pill">Gulp</span>
                <span class="pill">GitHub Actions</span>
                <span class="pill">Jenkins</span>
                <span class="pill">GitLab CI</span>
                <span class="pill">AWS (basic)</span>
                <span class="pill">Firebase (basic)</span>
                <span class="pill">Jest</span>
                <span class="pill">React Testing Library</span>
              </div>
            </div>
          </section>

          <section class="section step" id="similarweb" data-title="Similarweb" data-period="Nov 2024 — Present" data-location="Prague, Czechia">
            <div class="content animate">
              <h2 class="eyebrow">Similarweb</h2>
              <h3 class="title">Senior Software Engineer</h3>
              <p class="meta">Nov 2024 — Present · Prague, Czechia</p>
              <p class="desc">Details coming soon.</p>
            </div>
          </section>

          <section class="section step" id="sentinelone" data-title="SentinelOne" data-period="Sep 2024 — Oct 2024" data-location="Prague, Czechia">
            <div class="content animate">
              <h2 class="eyebrow">SentinelOne</h2>
              <h3 class="title">Staff Software Engineer</h3>
              <p class="meta">Sep 2024 — Oct 2024 · Prague, Czechia</p>
              <p class="desc">Details coming soon.</p>
            </div>
          </section>

          <section class="section outro" id="contact" data-title="Contact">
            <div class="content animate">
              <h2 class="title">Let’s connect</h2>
              <p class="lead">Open to challenging Frontend roles and architecture‑driven projects.</p>
              <div class="cta-row">
                <a class="btn primary" href="mailto:roksonix@gmail.com">Email me</a>
                <a class="btn ghost" href="Profile.pdf" download>Download PDF</a>
              </div>
            </div>
          </section>
        </main>

        <aside class="progress" aria-hidden="true"></aside>

        <script defer>
          const supportsScrollDriven = CSS && CSS.supports?.("animation-timeline: view()");
          document.documentElement.classList.toggle("no-sd", !supportsScrollDriven);

          if (!supportsScrollDriven && "IntersectionObserver" in window) {
            const observer = new IntersectionObserver(
              (entries) => {
                for (const entry of entries) {
                  if (entry.isIntersecting) entry.target.classList.add("is-visible");
                }
              },
              { root: document.querySelector('#viewport'), threshold: 0.25 }
            );
            document.querySelectorAll('.section .content').forEach((el) => observer.observe(el));
          }

          (function buildProgress() {
            const container = document.querySelector('.progress');
            const sections = Array.from(document.querySelectorAll('main .section'));
            const frag = document.createDocumentFragment();
            sections.forEach((sec, idx) => {
              const a = document.createElement('a');
              a.href = `#${sec.id}`;
              a.className = 'dot';
              a.title = sec.dataset.title || `Section ${idx + 1}`;
              frag.appendChild(a);
            });
            container?.appendChild(frag);

            const viewport = document.getElementById('viewport');
            const io = new IntersectionObserver((entries) => {
              const visible = entries.filter(e => e.isIntersecting).sort((a,b) => b.intersectionRatio - a.intersectionRatio)[0];
              if (!visible) return;
              const idx = sections.indexOf(visible.target);
              container.querySelectorAll('.dot').forEach((d,i) => d.classList.toggle('active', i === idx));
            }, { root: viewport, threshold: [0.5, 0.75] });
            sections.forEach(s => io.observe(s));
          })();

          // Smooth-scroll internal nav links into the scroll container
          function handleAnchorClick(e) {
            const anchor = e.target.closest('a[href^="#"]');
            if (!anchor) return;
            const id = anchor.getAttribute('href');
            if (!id || id === '#') return;
            const target = document.querySelector(id);
            if (target) {
              e.preventDefault();
              target.scrollIntoView({ behavior: 'smooth', block: 'start' });
              history.replaceState(null, '', id);
            }
          }
          document.querySelector('.progress')?.addEventListener('click', handleAnchorClick);

          if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
            document.documentElement.classList.add('reduced-motion');
          }
          (function introGate(){
            const viewport = document.getElementById('viewport');
            const section = document.getElementById('intro');
            const cube = document.getElementById('intro-cube');
            if (!viewport || !section || !cube) return;

            // Gate only while intro is in view the first time
            let gated = true;
            let rotationY = 30; // start angle must match CSS start
            let lastTs = 0;
            let pinnedScrollTop = viewport.scrollTop; // pin at current position

            const applyRotation = () => {
              cube.style.transform = `rotateX(-18deg) rotateY(${rotationY}deg)`;
            };
            applyRotation();

            const endGate = () => {
              if (!gated) return;
              gated = false;
              section.classList.remove('gate-active');
              cube.classList.add('spin');
            };

            const isIntroTopNearTop = () => {
              const rect = section.getBoundingClientRect();
              const vp = viewport.getBoundingClientRect();
              // Consider intro at top when its top is within 8px of viewport top
              return Math.abs(rect.top - vp.top) < 8;
            };

            const wheelHandler = (e) => {
              if (!gated) return;
              if (!isIntroTopNearTop()) { endGate(); return; }
              if (e.deltaY <= 0) return; // allow upward scroll naturally
              e.preventDefault();
              // Progress rotation by wheel delta
              rotationY = Math.max(-90, rotationY - e.deltaY * 0.35);
              applyRotation();
              if (rotationY <= -90) { endGate(); }
            };

            let touchStartY = null;
            const touchStart = (e) => { if (!gated) return; touchStartY = e.touches[0].clientY; };
            const touchMove = (e) => {
              if (!gated || touchStartY == null) return;
              if (!isIntroTopNearTop()) { endGate(); return; }
              const dy = touchStartY - e.touches[0].clientY; // swipe up positive
              if (dy <= 0) return;
              e.preventDefault();
              rotationY = Math.max(-90, rotationY - dy * 0.4);
              applyRotation();
              if (rotationY <= -90) { endGate(); }
            };
            const touchEnd = () => { touchStartY = null; };

            const keyHandler = (e) => {
              if (!gated) return;
              if (!isIntroTopNearTop()) { endGate(); return; }
              const keys = ['PageDown','ArrowDown','Space'];
              if (!keys.includes(e.key)) return;
              e.preventDefault();
              rotationY = Math.max(-90, rotationY - 10);
              applyRotation();
              if (rotationY <= -90) { endGate(); }
            };

            const onScroll = () => {
              if (!gated) return;
              const rect = section.getBoundingClientRect();
              const vp = viewport.getBoundingClientRect();
              // Keep gating only when intro is at the top edge
              if (Math.abs(rect.top - vp.top) > 8) { endGate(); return; }
              section.classList.add('gate-active');
              // Pin scroll to prevent container movement while rotating
              viewport.scrollTop = pinnedScrollTop;
            };

            viewport.addEventListener('wheel', wheelHandler, { passive: false });
            viewport.addEventListener('scroll', onScroll);
            viewport.addEventListener('touchstart', touchStart, { passive: true });
            // Prevent default space/arrow scroll while gated
            window.addEventListener('keydown', (e) => {
              if (!gated) return;
              const block = ['Space','ArrowDown','PageDown'];
              if (block.includes(e.key)) e.preventDefault();
            }, { capture: true });
            viewport.addEventListener('touchmove', touchMove, { passive: false });
            viewport.addEventListener('touchend', touchEnd, { passive: true });
            window.addEventListener('keydown', keyHandler);

            // When gate completes, unhook pinning and allow normal scroll
            const observer = new MutationObserver(() => {
              if (!section.classList.contains('gate-active')) {
                observer.disconnect();
                // no-op: listeners can remain; gating checks will ignore
              }
            });
            observer.observe(section, { attributes: true, attributeFilter: ['class'] });
          })();

          (function cubeFallback(){
            const cube = document.getElementById('intro-cube');
            const section = document.getElementById('intro');
            const viewport = document.getElementById('viewport');
            const reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            const supports = CSS && CSS.supports?.('animation-timeline: view()');
            if (!cube || !section || !viewport || supports || reduced) return;
            if (section.classList.contains('gate-active')) return; // disabled during gate
            if (document.getElementById('intro-cube')?.classList.contains('spin')) return; // already spinning
            const degStart = 30;
            const degEnd = -90;
            const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
            const lerp = (a, b, t) => a + (b - a) * t;
            const update = () => {
              const vpRect = viewport.getBoundingClientRect();
              const secRect = section.getBoundingClientRect();
              const range = vpRect.height + secRect.height;
              const progress = clamp((vpRect.bottom - secRect.top) / range, 0, 1);
              const y = lerp(degStart, degEnd, progress);
              cube.style.transform = `rotateX(-18deg) rotateY(${y}deg)`;
            };
            update();
            viewport.addEventListener('scroll', update, { passive: true });
            window.addEventListener('resize', update);
          })();
        </script>
    </body>
</html>
